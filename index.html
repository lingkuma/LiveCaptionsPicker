<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LiveCaptionsPicker - LunaTranslator</title>
    <link rel="icon" type="image/png" href="icon16.png">
    <link rel="shortcut icon" type="image/png" href="icon16.png">
    <style>
        :root {
            /* 黑暗模式变量 (默认) */
            --bg-color: #1a1a1a;
            --container-bg: #2d2d2d;
            --text-color: #e0e0e0;
            --text-secondary: #b0b0b0;
            --border-color: #404040;
            --header-color: #ffffff;
        }

        [data-theme="light"] {
            /* 浅色模式变量 */
            --bg-color: #f7f9fa;
            --container-bg: #ffffff;
            --text-color: #222;
            --text-secondary: #666;
            --border-color: #e6e6e6;
            --header-color: #333;
        }

        body {
            font-family: 'Georgia', 'Times New Roman', 'Microsoft YaHei', serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            font-size: 18px;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .container {
            max-width: 680px;
            margin: 0 auto;
            padding: 40px 20px;
            background-color: var(--container-bg);
            min-height: 100vh;
            transition: background-color 0.3s ease;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
            transition: border-color 0.3s ease;
        }

        .header h1 {
            margin: 0;
            color: var(--header-color);
            font-size: 2.2em;
            font-weight: 400;
            letter-spacing: -0.02em;
            transition: color 0.3s ease;
        }

        .status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .status.connected {
            background-color: #4caf50;
            color: white;
        }

        .status.disconnected {
            background-color: #f44336;
            color: white;
        }

        .captions-container {
            min-height: 60vh;
            padding: 0;
            background-color: transparent;
            line-height: 1.7;
        }

        /* 只对实时更新的内容禁止翻译 */
        .sentence.incomplete,
        .sentence.incomplete .sentence-text,
        .sentence.incomplete .word {
            /* 明确告诉沉浸翻译不要翻译正在更新的元素 */
            translate: no;
        }

        /* 为实时更新内容添加特定的排除标记 */
        .sentence.incomplete * {
            /* 防止沉浸翻译处理正在更新的内容 */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* 完成的句子允许翻译和选择 */
        .sentence.completed * {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }



        /* 底部固定高度的空白区域，用于提供滚动空间 */
        .bottom-spacer {
            height: 300px; /* 固定高度，提供滚动空间 */
            background-color: transparent;
        }

        .sentence {
            margin-bottom: 24px;
            padding: 0;
            border: none;
            background: transparent;
        }

        .sentence.completed {
            color: var(--text-color);
            transition: color 0.3s ease;
        }

        .sentence.incomplete {
            color: var(--text-secondary);
            position: relative;
            transition: color 0.3s ease;
        }

        .sentence.incomplete::after {
            content: '';
            display: inline-block;
            width: 2px;
            height: 1.2em;
            background-color: var(--text-color);
            margin-left: 2px;
            animation: blink 1s infinite;
            vertical-align: text-bottom;
            transition: background-color 0.3s ease;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .sentence-text {
            font-size: 1em;
            word-wrap: break-word;
            letter-spacing: 0.01em;
            margin: 0;
        }

        /* 单词级别样式 */
        .word {
            display: inline;
            color: var(--text-color);
            opacity: 1;
            background-color: transparent;
            padding: 0;
            margin: 0;
        }

        .word.stable {
            color: var(--text-color);
            opacity: 1;
        }

        .word.updating {
            color: var(--text-color);
            opacity: 1;
            background-color: transparent;
        }

        /* 完成句子中的单词都是稳定的 */
        .sentence.completed .word {
            color: var(--text-color);
            opacity: 1;
            background-color: transparent;
        }

        .controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }

        .btn {
            background-color: #007acc;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,122,204,0.3);
            min-width: 120px;
            text-align: center;
        }

        .btn:hover {
            background-color: #005a9e;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,122,204,0.4);
        }

        .btn.clear {
            background-color: #dc3545;
            box-shadow: 0 2px 8px rgba(220,53,69,0.3);
        }

        .btn.clear:hover {
            background-color: #c82333;
            box-shadow: 0 4px 12px rgba(220,53,69,0.4);
        }

        .btn.telegraph {
            background-color: #28a745;
            box-shadow: 0 2px 8px rgba(40,167,69,0.3);
        }

        .btn.telegraph:hover {
            background-color: #218838;
            box-shadow: 0 4px 12px rgba(40,167,69,0.4);
        }

        .btn.telegraph:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 8px rgba(108,117,125,0.3);
        }

        .btn.telegraph-with-translation {
            background-color: #17a2b8;
            box-shadow: 0 2px 8px rgba(23,162,184,0.3);
        }

        .btn.telegraph-with-translation:hover {
            background-color: #138496;
            box-shadow: 0 4px 12px rgba(23,162,184,0.4);
        }

        .btn.telegraph-with-translation:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 8px rgba(108,117,125,0.3);
        }

        .btn.scroll {
            background-color: #6f42c1;
            box-shadow: 0 2px 8px rgba(111,66,193,0.3);
        }

        .btn.scroll:hover {
            background-color: #5a32a3;
            box-shadow: 0 4px 12px rgba(111,66,193,0.4);
        }

        .btn.auto-scroll {
            background-color: #fd7e14;
            box-shadow: 0 2px 8px rgba(253,126,20,0.3);
        }

        .btn.auto-scroll:hover {
            background-color: #e8650e;
            box-shadow: 0 4px 12px rgba(253,126,20,0.4);
        }

        .btn.auto-scroll.active {
            background-color: #198754;
            box-shadow: 0 2px 8px rgba(25,135,84,0.3);
        }

        .btn.auto-scroll.active:hover {
            background-color: #157347;
            box-shadow: 0 4px 12px rgba(25,135,84,0.4);
        }

        .btn.comma-mode {
            background-color: #6f42c1;
            box-shadow: 0 2px 8px rgba(111,66,193,0.3);
        }

        .btn.comma-mode:hover {
            background-color: #5a32a3;
            box-shadow: 0 4px 12px rgba(111,66,193,0.4);
        }

        .btn.comma-mode.active {
            background-color: #198754;
            box-shadow: 0 2px 8px rgba(25,135,84,0.3);
        }

        .btn.comma-mode.active:hover {
            background-color: #157347;
            box-shadow: 0 4px 12px rgba(25,135,84,0.4);
        }

        .stats {
            position: fixed;
            bottom: 30px;
            left: 30px;
            color: var(--text-secondary);
            font-size: 12px;
            z-index: 1000;
            transition: color 0.3s ease;
        }

        /* 左上角按钮容器 - 竖直排列 */
        .top-left-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }

        .theme-toggle,
        .hide-controls-toggle,
        .lingkuma-install,
        .copy-luna-script,
        .download-luna,
        .tutorial-link,
        .github-link {
            background-color: var(--container-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            text-decoration: none;
            display: inline-block;
            text-align: center;
            min-width: 120px;
        }

        .theme-toggle:hover,
        .hide-controls-toggle:hover,
        .lingkuma-install:hover,
        .copy-luna-script:hover,
        .download-luna:hover,
        .tutorial-link:hover,
        .github-link:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .lingkuma-install {
            background-color: #4caf50;
            color: white;
            border-color: #4caf50;
        }

        .lingkuma-install:hover {
            background-color: #45a049;
            border-color: #45a049;
        }

        .copy-luna-script {
            background-color: #007acc;
            color: white;
            border-color: #007acc;
        }

        .copy-luna-script:hover {
            background-color: #005a9e;
            border-color: #005a9e;
        }

        .download-luna {
            background-color: #ff6b35;
            color: white;
            border-color: #ff6b35;
        }

        .download-luna:hover {
            background-color: #e55a2b;
            border-color: #e55a2b;
        }

        .tutorial-link {
            background-color: #9c27b0;
            color: white;
            border-color: #9c27b0;
        }

        .tutorial-link:hover {
            background-color: #7b1fa2;
            border-color: #7b1fa2;
        }

        .github-link {
            background-color: #24292e;
            color: white;
            border-color: #24292e;
        }

        .github-link:hover {
            background-color: #1b1f23;
            border-color: #1b1f23;
        }

        .editable-title {
            background: transparent;
            border: none;
            color: var(--header-color);
            font-size: 2.2em;
            font-weight: 400;
            letter-spacing: -0.02em;
            text-align: center;
            width: 100%;
            transition: color 0.3s ease;
            outline: none;
            font-family: inherit;
        }

        .editable-title:focus {
            background-color: var(--border-color);
            border-radius: 4px;
            padding: 4px 8px;
        }

        .controls-hidden .controls,
        .controls-hidden .stats,
        .controls-hidden .status,
        .controls-hidden .theme-toggle,
        .controls-hidden .hide-controls-toggle,
        .controls-hidden .copy-luna-script,
        .controls-hidden .download-luna,
        .controls-hidden .tutorial-link,
        .controls-hidden .lingkuma-install,
        .controls-hidden .github-link {
            opacity: 0;
            pointer-events: none;
        }

        /* 隐藏控件时，在隐藏按钮区域悬浮显示按钮 */
        .controls-hidden .hide-controls-toggle {
            transition: opacity 0.3s ease;
        }

        /* 为隐藏按钮添加悬浮区域 - 适应竖直布局 */
        .hide-controls-hover-area {
            position: fixed;
            top: 0;
            left: 0;
            width: 280px;
            height: 400px;
            z-index: 999;
            pointer-events: none;
        }

        .controls-hidden .hide-controls-hover-area {
            pointer-events: auto;
        }

        /* 悬浮时显示所有按钮 - 使用父元素hover */
        .controls-hidden .top-left-controls:hover .theme-toggle,
        .controls-hidden .top-left-controls:hover .hide-controls-toggle,
        .controls-hidden .top-left-controls:hover .copy-luna-script,
        .controls-hidden .top-left-controls:hover .download-luna,
        .controls-hidden .top-left-controls:hover .tutorial-link,
        .controls-hidden .top-left-controls:hover .lingkuma-install,
        .controls-hidden .top-left-controls:hover .github-link {
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        /* 逗号分割句子样式 */
        .comma-split-container {
            margin-top: 10px;
            padding: 10px;
            background-color: var(--container-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .comma-split-sentence {
            margin-bottom: 8px;
            padding: 4px 8px;
            background-color: var(--bg-color);
            border-radius: 4px;
            font-size: 0.95em;
            line-height: 1.5;
            transition: all 0.3s ease;
            border-left: 3px solid var(--border-color);
        }

        .comma-split-sentence:last-child {
            margin-bottom: 0;
        }

        .comma-split-sentence.updating {
            border-left-color: #007acc;
            background-color: rgba(0, 122, 204, 0.05);
        }

        .comma-split-sentence.stable {
            border-left-color: var(--text-secondary);
        }

        /* 逗号分割句子中的文本也需要防翻译保护 */
        .comma-split-sentence.updating,
        .comma-split-sentence.updating * {
            translate: no;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .comma-split-sentence.stable * {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .container {
                padding: 20px 15px;
            }

            .controls {
                bottom: 20px;
                right: 20px;
            }

            .stats {
                bottom: 20px;
                left: 20px;
                font-size: 11px;
            }

            .top-left-controls {
                top: 15px;
                left: 15px;
                gap: 8px;
            }

            .theme-toggle,
            .hide-controls-toggle,
            .lingkuma-install,
            .copy-luna-script,
            .download-luna,
            .tutorial-link,
            .github-link {
                padding: 6px 10px;
                font-size: 13px;
                min-width: 100px;
            }

            .hide-controls-hover-area {
                left: 0;
                width: 220px;
                height: 320px;
            }

            .btn {
                padding: 10px 16px;
                font-size: 13px;
                min-width: 100px;
            }
        }
    </style>
</head>
<body>
    <!-- 左上角按钮容器 - 竖直排列 -->
    <div class="top-left-controls">
  

        <a href="https://www.lingkuma.org/live-captions-zh"
           target="_blank"
           class="tutorial-link">
            📖 使用教程
        </a>

        <div id="copy-luna-script" class="copy-luna-script" onclick="copyLunaScript()">
            📋 复制Luna脚本
        </div>

        <a href="https://docs.lunatranslator.org/"
           target="_blank"
           class="download-luna">
            🌙 LunaTranslator
        </a>
        <a href="https://chromewebstore.google.com/detail/lingkuma-language-learnin/denpakphibjnpnnkcnhiniicbffdamfh"
        target="_blank"
        class="lingkuma-install">
         🐻 Lingkuma
     </a>

     <a href="https://github.com/lingkuma/LiveCaptionsPicker"
     target="_blank"
     class="github-link">
      🐙 GitHub
  </a>
        <div id="theme-toggle" class="theme-toggle" onclick="toggleTheme()">
            🌙 浅色模式
        </div>

        <div id="hide-controls-toggle" class="hide-controls-toggle" onclick="toggleControls()">
            👁️ 隐藏控件
        </div>

        
    </div>

    <!-- 隐藏状态下的悬浮触发区域 -->
    <div id="hide-controls-hover-area" class="hide-controls-hover-area"></div>

    <div id="status" class="status disconnected">
        未连接
    </div>

    <div class="container">
        <div class="header">
            <input type="text" class="editable-title" value="Title edit" placeholder="点击编辑标题">
        </div>

        <div id="captions-container" class="captions-container">
            <div id="content-wrapper" class="content-wrapper">
                <div class="sentence completed">
                    <div class="sentence-text">Waiting for captions...</div>
                </div>
            </div>
        </div>

        <!-- 底部固定空白区域，提供滚动空间 -->
        <div class="bottom-spacer"></div>
    </div>

    <div class="controls">
        <button class="btn" onclick="toggleConnection()">
            <span id="connect-btn-text">开始连接</span>
        </button>
        <button class="btn clear" onclick="clearCaptions()">清空字幕</button>
        <button class="btn scroll" onclick="scrollToTop()">滚动到顶部</button>
        <button class="btn scroll" onclick="scrollToBottom()">滚动到底部</button>
        <button id="auto-scroll-btn" class="btn auto-scroll active" onclick="toggleAutoScroll()">
            <span id="auto-scroll-text">🔄 自动滚动</span>
        </button>
        <button id="comma-mode-btn" class="btn comma-mode" onclick="toggleCommaMode()">
            <span id="comma-mode-text">📝 逗号换行</span>
        </button>
        <button id="telegraph-btn" class="btn telegraph" onclick="sendToTelegraph()">分享原文</button>
        <button id="telegraph-with-translation-btn" class="btn telegraph-with-translation" onclick="sendToTelegraphWithTranslation()">分享附沉浸翻译</button>
    </div>

    <div class="stats">
        <div>监听时间: <span id="listening-time">00:00:00</span></div>
        <div>单词总数: <span id="total-words">0</span></div>
        <div>完成句子: <span id="completed-count">0</span></div>
        <div>最后更新: <span id="last-update">从未</span></div>
    </div>

    <script>
        let isConnected = false;
        let pollInterval = null;
        let completedSentences = [];
        let currentIncomplete = '';
        let lastTimestamp = 0;
        let lastLine = '';  // 记录上次的line内容
        let lastCompletedCount = 0;  // 记录上次完成句子的数量
        let autoScrollEnabled = true;  // 自动滚动开关
        let wordStabilizeTimer = null;  // 单词稳定化定时器
        let lastStableContent = '';  // 记录上次稳定的内容
        let contentChangeCount = 0;  // 内容变化计数
        let scrollTimer = null;  // 滚动定时器
        let startTime = null;  // 开始监听的时间
        let totalWords = 0;  // 总单词数
        let timeUpdateInterval = null;  // 时间更新定时器
        let commaMode = false;  // 逗号换行模式开关
        let commaSplitSentences = [];  // 逗号分割的句子数组

        const statusEl = document.getElementById('status');
        const captionsContainer = document.getElementById('captions-container');
        const contentWrapper = document.getElementById('content-wrapper');
        const connectBtnText = document.getElementById('connect-btn-text');
        const completedCountEl = document.getElementById('completed-count');
        const lastUpdateEl = document.getElementById('last-update');
        const listeningTimeEl = document.getElementById('listening-time');
        const totalWordsEl = document.getElementById('total-words');
        const themeToggleEl = document.getElementById('theme-toggle');
        const hideControlsToggleEl = document.getElementById('hide-controls-toggle');
        const hideControlsHoverAreaEl = document.getElementById('hide-controls-hover-area');
        const autoScrollBtnEl = document.getElementById('auto-scroll-btn');
        const autoScrollTextEl = document.getElementById('auto-scroll-text');
        const commaModeBtnEl = document.getElementById('comma-mode-btn');
        const commaModeTextEl = document.getElementById('comma-mode-text');
        let controlsHidden = false;

        function updateStatus(connected) {
            isConnected = connected;
            if (connected) {
                statusEl.className = 'status connected';
                statusEl.textContent = '已连接';
                connectBtnText.textContent = '断开连接';
            } else {
                statusEl.className = 'status disconnected';
                statusEl.textContent = '未连接';
                connectBtnText.textContent = '开始连接';
            }
        }

        function toggleConnection() {
            if (isConnected) {
                stopPolling();
            } else {
                startPolling();
            }
        }

        function startPolling() {
            if (pollInterval) return;

            updateStatus(true);

            // 记录开始时间
            if (!startTime) {
                startTime = new Date();
                startTimeUpdateInterval();
            }

            pollInterval = setInterval(fetchCaptions, 300); // 每300ms获取一次数据，更快响应
            fetchCaptions(); // 立即获取一次
        }

        function stopPolling() {
            if (pollInterval) {
                clearInterval(pollInterval);
                pollInterval = null;
            }

            // 停止时间更新
            stopTimeUpdateInterval();

            updateStatus(false);
        }

        async function fetchCaptions() {
            try {
                const response = await fetch('http://localhost:8765/captions');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                updateCaptions(data);

            } catch (error) {
                console.error('获取字幕失败:', error);
                updateStatus(false);
                setTimeout(() => {
                    if (isConnected) {
                        startPolling();
                    }
                }, 2000);
            }
        }

        function updateCaptions(data) {
            const { current_line, timestamp } = data;

            // 检查是否有新数据
            if (timestamp <= lastTimestamp && current_line === lastLine) {
                return;
            }

            lastTimestamp = timestamp;

            // 如果当前行为空，只在之前有内容时才清空未完成句子
            if (!current_line || !current_line.trim()) {
                if (currentIncomplete.trim()) {
                    console.log('清空未完成句子:', currentIncomplete);
                    currentIncomplete = '';
                    renderCaptions();
                    updateStats();
                }
                return;
            }

            const newLine = current_line.trim();

            // 检测内容稳定性
            if (newLine !== lastStableContent) {
                contentChangeCount++;

                // 移除数据不稳定检测，始终处理更新
                console.log('处理新数据更新:', newLine);

                // 检测是否是完全不同的内容（可能是重置或新开始）
                const lengthCondition = lastLine && newLine.length < lastLine.length * 0.5;
                const contentCondition = lastLine && !lastLine.toLowerCase().includes(newLine.toLowerCase().substring(0, Math.min(20, newLine.length)));

                console.log('🔍 内容重置检测:', {
                    lastLineLength: lastLine ? lastLine.length : 0,
                    newLineLength: newLine.length,
                    lengthThreshold: lastLine ? lastLine.length * 0.5 : 0,
                    lengthCondition: lengthCondition,
                    contentCondition: contentCondition,
                    checkString: newLine.toLowerCase().substring(0, Math.min(20, newLine.length))
                });

                if (lengthCondition && contentCondition) {
                    console.log('检测到内容重置，从:', lastLine, '到:', newLine);

                    // 在重置之前，先保存当前未完成的句子（如果有的话）
                    if (currentIncomplete.trim() && !isAlreadyCompleted(currentIncomplete)) {
                        console.log('🔄 内容重置前保存未完成句子:', currentIncomplete);
                        completedSentences.push(currentIncomplete);
                        updateWordCount(currentIncomplete);
                        console.log('  ✅ 句子已保存到历史记录');
                    }

                    // 然后设置新的未完成句子
                    currentIncomplete = newLine;
                } else {
                    // 正常处理新的line数据
                    processNewLine(newLine);
                }

                // 更新稳定内容记录
                if (newLine.length > lastStableContent.length) {
                    lastStableContent = newLine;
                    contentChangeCount = 0; // 重置变化计数
                }
            } else {
                // 内容没有变化，重置变化计数
                contentChangeCount = 0;
            }

            lastLine = current_line;

            renderCaptions();
            updateStats();

            // 如果启用了逗号换行模式，处理逗号分割
            if (commaMode) {
                processCommaMode();
            }
        }

        function processNewLine(line) {
            // 句子结束标点
            const sentenceEndings = '.。！!？?';

            // 检查是否包含句子结束标点
            if (sentenceEndings.split('').some(char => line.includes(char))) {
                // 分割句子
                const sentences = [];
                let tempSentence = '';

                for (const char of line) {
                    tempSentence += char;
                    if (sentenceEndings.includes(char)) {
                        const sentence = tempSentence.trim();
                        if (sentence && !isAlreadyCompleted(sentence)) {
                            sentences.push(sentence);
                        }
                        tempSentence = '';
                    }
                }

                // 添加完整句子到历史记录
                sentences.forEach(sentence => {
                    if (sentence && !isAlreadyCompleted(sentence)) {
                        completedSentences.push(sentence);
                        // 更新单词总数
                        updateWordCount(sentence);
                    }
                });

                // 处理剩余未完成的文本
                currentIncomplete = tempSentence.trim();

            } else {
                // 没有句子结束标点，先检查是否是内容重置（优先级更高）
                const isContentReset = currentIncomplete.trim() &&
                                     line.length < currentIncomplete.length * 0.5 &&
                                     !currentIncomplete.toLowerCase().includes(line.toLowerCase().substring(0, Math.min(20, line.length)));

                if (isContentReset) {
                    console.log('🔄 在processNewLine中检测到内容重置:');
                    console.log('  之前句子:', currentIncomplete);
                    console.log('  新句子:', line);
                    console.log('  自动保存之前的句子');

                    // 保存之前的未完成句子
                    if (!isAlreadyCompleted(currentIncomplete)) {
                        completedSentences.push(currentIncomplete);
                        updateWordCount(currentIncomplete);
                        console.log('  ✅ 句子已保存到历史记录');
                    } else {
                        console.log('  ⚠️ 句子已存在，跳过保存');
                    }

                    // 设置新的未完成句子
                    currentIncomplete = line;
                } else if (currentIncomplete.trim() && !isSentenceContinuation(currentIncomplete, line)) {
                    // 检测到句子突然切换，保存之前的未完成句子
                    console.log('🔄 检测到句子突然切换:');
                    console.log('  之前句子:', currentIncomplete);
                    console.log('  新句子:', line);
                    console.log('  自动保存之前的句子');

                    // 将之前的未完成句子保存为完成句子（不添加句号，保持原样）
                    if (!isAlreadyCompleted(currentIncomplete)) {
                        completedSentences.push(currentIncomplete);
                        // 更新单词总数
                        updateWordCount(currentIncomplete);
                        console.log('  ✅ 句子已保存到历史记录');
                    } else {
                        console.log('  ⚠️ 句子已存在，跳过保存');
                    }

                    // 设置新的未完成句子
                    currentIncomplete = line;
                } else if (currentIncomplete.trim()) {
                    console.log('📝 句子延续更新:', line);
                    // 设置新的未完成句子
                    currentIncomplete = line;
                } else {
                    // 设置新的未完成句子
                    currentIncomplete = line;
                }
            }
        }

        // 检查新句子是否是当前未完成句子的延续
        function isSentenceContinuation(currentSentence, newSentence) {
            if (!currentSentence || !newSentence) {
                return false;
            }

            const current = currentSentence.trim().toLowerCase();
            const newText = newSentence.trim().toLowerCase();

            // 如果两个句子完全相同，认为是延续
            if (current === newText) {
                return true;
            }

            // 如果新句子完全包含当前句子，认为是延续
            if (newText.includes(current)) {
                return true;
            }

            // 如果当前句子包含新句子，可能是回退修正，也认为是延续
            if (current.includes(newText)) {
                return true;
            }

            // 检查单词级别的重叠
            const currentWords = current.split(/\s+/).filter(w => w);
            const newWords = newText.split(/\s+/).filter(w => w);

            if (currentWords.length === 0 || newWords.length === 0) {
                return false;
            }

            // 如果其中一个句子太短（少于3个单词），使用更宽松的检测
            if (currentWords.length < 3 || newWords.length < 3) {
                // 检查是否有任何单词重叠
                const hasOverlap = currentWords.some(word => newWords.includes(word));
                console.log('🔍 短句子重叠检测:', {
                    currentWords: currentWords,
                    newWords: newWords,
                    hasOverlap: hasOverlap
                });
                return hasOverlap;
            }

            // 计算前几个单词的匹配度
            const checkLength = Math.min(currentWords.length, newWords.length, 5); // 检查前5个单词
            let matchCount = 0;

            for (let i = 0; i < checkLength; i++) {
                if (currentWords[i] === newWords[i]) {
                    matchCount++;
                }
            }

            // 如果前面的单词有50%以上匹配，认为是延续
            const matchRatio = matchCount / checkLength;
            if (matchRatio >= 0.5) {
                return true;
            }

            // 检查是否新句子以当前句子的最后几个单词开始
            if (currentWords.length >= 2 && newWords.length >= 2) {
                const lastWords = currentWords.slice(-2); // 取最后2个单词
                const firstWords = newWords.slice(0, 2); // 取前2个单词

                if (lastWords.some(word => firstWords.includes(word))) {
                    return true;
                }
            }

            // 最后检查：计算整体相似度，如果相似度很高，也认为是延续
            const similarity = calculateSimilarity(current, newText);
            if (similarity > 0.3) { // 30%以上相似度认为是延续
                return true;
            }

            return false;
        }

        // 检查句子是否已经完成（更严格的重复检测）
        function isAlreadyCompleted(sentence) {
            const normalizedSentence = sentence.toLowerCase().trim();

            return completedSentences.some(completed => {
                const normalizedCompleted = completed.toLowerCase().trim();

                // 完全相同
                if (normalizedCompleted === normalizedSentence) {
                    return true;
                }

                // 检查相似度（防止轻微变化的重复）
                const similarity = calculateSimilarity(normalizedCompleted, normalizedSentence);
                if (similarity > 0.85) { // 85%以上相似度认为是重复
                    console.log('检测到相似句子:', {
                        existing: completed,
                        new: sentence,
                        similarity: similarity
                    });
                    return true;
                }

                return false;
            });
        }

        // 计算两个字符串的相似度
        function calculateSimilarity(str1, str2) {
            const words1 = str1.split(/\s+/);
            const words2 = str2.split(/\s+/);

            const maxLength = Math.max(words1.length, words2.length);
            if (maxLength === 0) return 1;

            let matchCount = 0;
            const minLength = Math.min(words1.length, words2.length);

            for (let i = 0; i < minLength; i++) {
                if (words1[i] === words2[i]) {
                    matchCount++;
                }
            }

            return matchCount / maxLength;
        }

        function renderCaptions() {
            let shouldScheduleScroll = false;

            // 只添加新的完成句子，不重新渲染已存在的
            if (completedSentences.length > lastCompletedCount) {
                for (let i = lastCompletedCount; i < completedSentences.length; i++) {
                    const sentence = completedSentences[i];
                    if (sentence.trim()) {
                        const sentenceEl = createSentenceElementWithWords(sentence, true, `completed-${i}`);

                        // 如果有未完成的句子，插入到它之前
                        const incompleteEl = document.getElementById('current-incomplete');
                        if (incompleteEl) {
                            contentWrapper.insertBefore(sentenceEl, incompleteEl);
                        } else {
                            contentWrapper.appendChild(sentenceEl);
                        }
                    }
                }
                lastCompletedCount = completedSentences.length;
                shouldScheduleScroll = true;
            }

            // 更新或创建当前未完成的句子
            const hadIncomplete = document.getElementById('current-incomplete') !== null;
            updateIncompleteElement();
            const hasIncomplete = document.getElementById('current-incomplete') !== null;

            // 如果新创建了未完成句子，也需要调整滚动位置
            if (!hadIncomplete && hasIncomplete) {
                shouldScheduleScroll = true;
            }

            // 安排滚动调整，保持新句子在70%位置
            if (shouldScheduleScroll && autoScrollEnabled) {
                scheduleAutoScroll();
            }
        }

        function updateIncompleteElement() {
            const existingIncomplete = document.getElementById('current-incomplete');

            if (currentIncomplete.trim()) {
                if (existingIncomplete) {
                    // 使用智能单词级更新
                    updateWordsInElement(existingIncomplete, currentIncomplete);
                } else {
                    // 创建新的未完成句子元素
                    const incompleteEl = createSentenceElementWithWords(currentIncomplete, false, 'current-incomplete');
                    contentWrapper.appendChild(incompleteEl);
                }
            } else {
                // 如果没有未完成的句子，移除现有的未完成元素
                if (existingIncomplete) {
                    existingIncomplete.remove();
                }
            }
        }

        // 智能单词级更新函数
        function updateWordsInElement(element, newText) {
            // 添加安全检查，确保元素仍然在DOM中
            if (!element || !element.isConnected) {
                console.warn('尝试更新已断开连接的元素，跳过更新');
                return;
            }

            const textContainer = element.querySelector('.sentence-text');
            if (!textContainer || !textContainer.isConnected) {
                console.warn('文本容器不存在或已断开连接，跳过更新');
                return;
            }

            const oldText = textContainer.getAttribute('data-text') || '';
            const oldWords = oldText.trim().split(/\s+/).filter(w => w);
            const newWords = newText.trim().split(/\s+/).filter(w => w);

            // 找到第一个不同的单词位置
            let firstDiffIndex = 0;
            while (firstDiffIndex < Math.min(oldWords.length, newWords.length) &&
                   oldWords[firstDiffIndex] === newWords[firstDiffIndex]) {
                firstDiffIndex++;
            }

            // 如果只是在末尾添加单词，只添加新单词
            if (firstDiffIndex === oldWords.length && newWords.length > oldWords.length) {
                // 只添加新单词
                for (let i = firstDiffIndex; i < newWords.length; i++) {
                    // 再次检查容器是否仍然连接
                    if (!textContainer.isConnected) {
                        console.warn('文本容器在更新过程中断开连接，停止更新');
                        return;
                    }

                    // 如果不是第一个单词且容器中已有内容，添加空格
                    if (i > 0 || textContainer.childNodes.length > 0) {
                        textContainer.appendChild(document.createTextNode(' '));
                    }
                    const wordSpan = createWordElement(newWords[i], false, false); // 未完成句子中的单词
                    textContainer.appendChild(wordSpan);
                }
            } else if (firstDiffIndex < newWords.length) {
                // 有修改或删除，需要重新渲染从修改位置开始的所有单词

                // 移除从修改位置开始的所有内容
                const childNodes = Array.from(textContainer.childNodes);
                let nodeIndex = 0;
                let wordCount = 0;

                // 找到对应修改位置的DOM节点
                for (let i = 0; i < childNodes.length && wordCount < firstDiffIndex; i++) {
                    if (childNodes[i].nodeType === Node.ELEMENT_NODE &&
                        childNodes[i].classList && childNodes[i].classList.contains('word')) {
                        wordCount++;
                    }
                    nodeIndex = i + 1;
                }

                // 安全地移除从修改位置开始的所有节点
                try {
                    while (textContainer.childNodes.length > nodeIndex && textContainer.isConnected) {
                        const lastChild = textContainer.lastChild;
                        if (lastChild && lastChild.parentNode === textContainer) {
                            textContainer.removeChild(lastChild);
                        } else {
                            break; // 如果无法安全移除，停止操作
                        }
                    }
                } catch (error) {
                    console.warn('移除子节点时出错:', error);
                    return;
                }

                // 添加修改后的单词
                for (let i = firstDiffIndex; i < newWords.length; i++) {
                    // 再次检查容器是否仍然连接
                    if (!textContainer.isConnected) {
                        console.warn('文本容器在更新过程中断开连接，停止更新');
                        return;
                    }

                    if (i > firstDiffIndex || (firstDiffIndex > 0 && textContainer.childNodes.length > 0)) {
                        textContainer.appendChild(document.createTextNode(' '));
                    }
                    const wordSpan = createWordElement(newWords[i], false, false); // 未完成句子中的单词
                    textContainer.appendChild(wordSpan);
                }
            }

            // 更新存储的文本
            if (textContainer.isConnected) {
                textContainer.setAttribute('data-text', newText);
            }

            // 启动单词稳定化定时器
            startWordStabilizeTimer();
        }

        // 启动单词稳定化定时器
        function startWordStabilizeTimer() {
            // 清除之前的定时器
            if (wordStabilizeTimer) {
                clearTimeout(wordStabilizeTimer);
            }

            // 设置新的定时器，2秒后将更新中的单词标记为稳定
            wordStabilizeTimer = setTimeout(() => {
                stabilizeWords();
            }, 2000);
        }

        // 将更新中的单词标记为稳定
        function stabilizeWords() {
            const incompleteElement = document.getElementById('current-incomplete');
            if (incompleteElement) {
                const updatingWords = incompleteElement.querySelectorAll('.word.updating');
                updatingWords.forEach(word => {
                    word.classList.remove('updating');
                    word.classList.add('stable');
                });
            }
        }

        // 创建单词元素
        function createWordElement(word, isStable, isInCompletedSentence = false) {
            const span = document.createElement('span');
            span.className = `word ${isStable ? 'stable' : 'updating'}`;
            span.textContent = word;

            // 只对未完成句子中的单词添加防翻译属性
            if (!isInCompletedSentence) {
                addNoTranslateAttributes(span);
            }

            return span;
        }

        // 添加防翻译属性的辅助函数（只用于实时更新的内容）
        function addNoTranslateAttributes(element) {
            element.setAttribute('data-immersive-translate-ignore', 'true');
            element.setAttribute('translate', 'no');
            element.setAttribute('notranslate', 'true');
            element.setAttribute('data-no-translate', 'true');
        }

        // 移除防翻译属性的辅助函数（当句子完成时使用）
        function removeNoTranslateAttributes(element) {
            element.removeAttribute('data-immersive-translate-ignore');
            element.removeAttribute('translate');
            element.removeAttribute('notranslate');
            element.removeAttribute('data-no-translate');
        }

        // 创建带单词分割的句子元素
        function createSentenceElementWithWords(text, isCompleted, id) {
            const div = document.createElement('div');
            div.className = `sentence ${isCompleted ? 'completed' : 'incomplete'}`;
            div.id = id;

            // 只对未完成的句子添加防翻译属性
            if (!isCompleted) {
                addNoTranslateAttributes(div);
            }

            const textDiv = document.createElement('div');
            textDiv.className = 'sentence-text';
            textDiv.setAttribute('data-text', text);

            // 只对未完成的句子添加防翻译属性
            if (!isCompleted) {
                addNoTranslateAttributes(textDiv);
            }

            // 将文本分割为单词并创建对应的元素
            const words = text.trim().split(/\s+/).filter(w => w);
            words.forEach((word, index) => {
                if (index > 0) {
                    textDiv.appendChild(document.createTextNode(' '));
                }
                const wordSpan = createWordElement(word, isCompleted, isCompleted);
                textDiv.appendChild(wordSpan);
            });

            div.appendChild(textDiv);
            return div;
        }

        function createSentenceElement(text, isCompleted, id) {
            const div = document.createElement('div');
            div.className = `sentence ${isCompleted ? 'completed' : 'incomplete'}`;
            div.id = id;

            // 只对未完成的句子添加防翻译属性
            if (!isCompleted) {
                addNoTranslateAttributes(div);
            }

            const textDiv = document.createElement('div');
            textDiv.className = 'sentence-text';
            textDiv.textContent = text;

            // 只对未完成的句子添加防翻译属性
            if (!isCompleted) {
                addNoTranslateAttributes(textDiv);
            }

            div.appendChild(textDiv);
            return div;
        }

        // 安排自动滚动（保持新句子在70%位置）
        function scheduleAutoScroll() {
            // 清除之前的定时器
            if (scrollTimer) {
                clearTimeout(scrollTimer);
            }

            // 延迟滚动，等待文本稍微稳定
            scrollTimer = setTimeout(() => {
                if (autoScrollEnabled) {
                    smoothScrollToBottom();
                }
            }, 500); // 0.5秒后执行滚动，更快响应
        }

        // 滚动让新句子位置保持在页面70%位置
        function smoothScrollToBottom() {
            // 获取当前正在更新的句子元素（未完成的句子或最新完成的句子）
            const incompleteEl = document.getElementById('current-incomplete');
            const targetElement = incompleteEl || contentWrapper.lastElementChild;

            if (!targetElement) return;

            // 计算目标位置：页面高度的70%
            const viewportHeight = window.innerHeight;
            const targetViewportPosition = viewportHeight * 0.5;

            // 获取目标元素当前在页面中的位置
            const elementRect = targetElement.getBoundingClientRect();
            const elementCurrentPosition = elementRect.top;

            // 计算需要滚动的距离，让元素移动到70%位置
            const scrollDistance = elementCurrentPosition - targetViewportPosition;

            // 只有当需要滚动距离大于20px时才滚动（避免微小调整）
            if (Math.abs(scrollDistance) > 20) {
                const currentScroll = window.scrollY;
                const targetScroll = currentScroll + scrollDistance;

                window.scrollTo({
                    top: targetScroll,
                    behavior: 'smooth'
                });
            }
        }

        function clearCaptions() {
            contentWrapper.innerHTML = '<div class="sentence completed"><div class="sentence-text">字幕已清空，等待新数据...</div></div>';
            completedSentences = [];
            currentIncomplete = '';
            lastLine = '';  // 重置上次line记录
            lastTimestamp = 0;  // 重置时间戳
            lastCompletedCount = 0;  // 重置完成句子计数
            lastStableContent = '';  // 重置稳定内容记录
            contentChangeCount = 0;  // 重置内容变化计数

            // 重置统计数据
            startTime = null;
            totalWords = 0;
            stopTimeUpdateInterval();

            // 清除单词稳定化定时器
            if (wordStabilizeTimer) {
                clearTimeout(wordStabilizeTimer);
                wordStabilizeTimer = null;
            }

            // 清除滚动定时器
            if (scrollTimer) {
                clearTimeout(scrollTimer);
                scrollTimer = null;
            }

            // 清除逗号分割相关数据
            commaSplitSentences = [];
            if (window.commaSplitStabilizeTimer) {
                clearTimeout(window.commaSplitStabilizeTimer);
                window.commaSplitStabilizeTimer = null;
            }

            updateStats();
        }

        function scrollToBottom() {
            // 使用新的平滑滚动机制
            smoothScrollToBottom();
        }

        function scrollToTop() {
            // 滚动到页面顶部
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        function toggleAutoScroll() {
            autoScrollEnabled = !autoScrollEnabled;

            if (autoScrollEnabled) {
                autoScrollBtnEl.classList.add('active');
                autoScrollTextEl.textContent = '🔄 自动滚动';
            } else {
                autoScrollBtnEl.classList.remove('active');
                autoScrollTextEl.textContent = '⏸️ 手动滚动';
            }

            // 保存设置到本地存储
            localStorage.setItem('autoScrollEnabled', autoScrollEnabled);
        }

        function updateStats() {
            completedCountEl.textContent = completedSentences.length;
            lastUpdateEl.textContent = new Date().toLocaleTimeString();
            totalWordsEl.textContent = totalWords;
            updateListeningTime();
        }

        // 更新单词总数
        function updateWordCount(sentence) {
            if (sentence && sentence.trim()) {
                const words = sentence.trim().split(/\s+/).filter(w => w);
                totalWords += words.length;
            }
        }

        // 开始时间更新定时器
        function startTimeUpdateInterval() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
            }
            timeUpdateInterval = setInterval(updateListeningTime, 1000); // 每秒更新一次
        }

        // 停止时间更新定时器
        function stopTimeUpdateInterval() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
                timeUpdateInterval = null;
            }
        }

        // 更新监听时间显示
        function updateListeningTime() {
            if (!startTime || !listeningTimeEl) {
                if (listeningTimeEl) {
                    listeningTimeEl.textContent = '00:00:00';
                }
                return;
            }

            const now = new Date();
            const elapsed = Math.floor((now - startTime) / 1000); // 秒数

            const hours = Math.floor(elapsed / 3600);
            const minutes = Math.floor((elapsed % 3600) / 60);
            const seconds = elapsed % 60;

            const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            listeningTimeEl.textContent = timeString;
        }

        // 复制Luna脚本功能
        async function copyLunaScript() {
            const lunaScriptContent = `
import json
import threading
import time
import socket

_current_line = ""  # 当前行数据
_server_socket = None  # 服务器socket
_server_thread = None  # 服务器线程
_server_running = False  # 服务器运行状态

def handle_request(client_socket):
    """处理单个HTTP请求"""
    try:
        request = client_socket.recv(1024).decode('utf-8')

        if 'GET /captions' in request:
            # 构造响应数据
            data = {
                'current_line': _current_line,
                'timestamp': time.time()
            }

            response_body = json.dumps(data, ensure_ascii=False)
            response = f"""HTTP/1.1 200 OK\\r
Content-Type: application/json; charset=utf-8\\r
Access-Control-Allow-Origin: *\\r
Content-Length: {len(response_body.encode('utf-8'))}\\r
\\r
{response_body}"""
        else:
            response = "HTTP/1.1 404 Not Found\\r\\n\\r\\n"

        client_socket.send(response.encode('utf-8'))
    except Exception as e:
        print(f"处理请求错误: {e}")
    finally:
        client_socket.close()

def server_loop():
    """服务器主循环"""
    global _server_socket, _server_running

    while _server_running:
        try:
            client_socket, addr = _server_socket.accept()
            # 在新线程中处理请求
            client_thread = threading.Thread(target=handle_request, args=(client_socket,), daemon=True)
            client_thread.start()
        except Exception as e:
            if _server_running:  # 只在服务器运行时打印错误
                print(f"接受连接错误: {e}")

def start_server():
    """启动HTTP服务器"""
    global _server_socket, _server_thread, _server_running

    if _server_socket is None:
        try:
            print("正在启动Caption服务器...")
            _server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            _server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            _server_socket.bind(('127.0.0.1', 8765))
            _server_socket.listen(5)
            _server_running = True

            _server_thread = threading.Thread(target=server_loop, daemon=True)
            _server_thread.start()
            print("Caption server started on http://127.0.0.1:8765")
        except Exception as e:
            print(f"Failed to start server: {e}")
            # 尝试其他端口
            try:
                print("尝试端口8766...")
                _server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                _server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                _server_socket.bind(('127.0.0.1', 8766))
                _server_socket.listen(5)
                _server_running = True

                _server_thread = threading.Thread(target=server_loop, daemon=True)
                _server_thread.start()
                print("Caption server started on http://127.0.0.1:8766")
            except Exception as e2:
                print(f"端口8766也失败: {e2}")

def stop_server():
    """停止HTTP服务器"""
    global _server_socket, _server_thread, _server_running

    _server_running = False
    if _server_socket:
        _server_socket.close()
        _server_socket = None
        _server_thread = None

def POSTSOLVE(line):
    """
    Luna脚本接口函数
    - 不做任何缓存处理
    - 只是将当前line数据提供给网页端
    - Luna正常返回line内容
    """
    global _current_line

    print(f"POSTSOLVE被调用，line: '{line}'")  # 调试信息

    # 启动服务器（如果还没启动）
    start_server()

    # 更新当前行数据供网页端获取
    _current_line = line if line else ""
    print(f"更新_current_line: '{_current_line}'")  # 调试信息

    # Luna直接返回原始内容，不做任何处理
    return line if line else ""
`.trim();

            try {
                await navigator.clipboard.writeText(lunaScriptContent);

                // 临时更改按钮文本以显示成功
                const copyBtn = document.getElementById('copy-luna-script');
                const originalText = copyBtn.innerHTML;
                copyBtn.innerHTML = '✅ 已复制!';
                copyBtn.style.backgroundColor = '#28a745';

                setTimeout(() => {
                    copyBtn.innerHTML = originalText;
                    copyBtn.style.backgroundColor = '#007acc';
                }, 2000);

            } catch (err) {
                console.error('复制失败:', err);
                alert('复制失败，请手动复制脚本内容');
            }
        }

        // 主题切换功能
        function toggleTheme() {
            const currentTheme = document.body.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';

            document.body.setAttribute('data-theme', newTheme);

            // 更新按钮文本
            if (newTheme === 'light') {
                themeToggleEl.innerHTML = '🌙 黑暗模式';
            } else {
                themeToggleEl.innerHTML = '☀️ 浅色模式';
            }

            // 保存主题设置到本地存储
            localStorage.setItem('theme', newTheme);
        }

        // 控件隐藏/显示功能
        function toggleControls() {
            controlsHidden = !controlsHidden;

            if (controlsHidden) {
                document.body.classList.add('controls-hidden');
                hideControlsToggleEl.innerHTML = '👁️ 显示控件';
            } else {
                document.body.classList.remove('controls-hidden');
                hideControlsToggleEl.innerHTML = '👁️ 隐藏控件';
            }

            // 保存设置到本地存储
            localStorage.setItem('controlsHidden', controlsHidden);
        }

        // 初始化主题
        function initTheme() {
            // 从本地存储获取主题设置，默认为黑暗模式
            const savedTheme = localStorage.getItem('theme') || 'dark';
            document.body.setAttribute('data-theme', savedTheme);

            // 更新按钮文本
            if (savedTheme === 'light') {
                themeToggleEl.innerHTML = '🌙 黑暗模式';
            } else {
                themeToggleEl.innerHTML = '☀️ 浅色模式';
            }
        }

        // 初始化控件显示状态
        function initControls() {
            // 从本地存储获取控件显示设置
            const savedControlsHidden = localStorage.getItem('controlsHidden') === 'true';
            controlsHidden = savedControlsHidden;

            if (controlsHidden) {
                document.body.classList.add('controls-hidden');
                hideControlsToggleEl.innerHTML = '👁️ 显示控件';
            } else {
                document.body.classList.remove('controls-hidden');
                hideControlsToggleEl.innerHTML = '👁️ 隐藏控件';
            }

            // 设置悬浮区域的事件监听
            setupHoverEvents();
        }

        // 初始化自动滚动设置
        function initAutoScroll() {
            // 从本地存储获取自动滚动设置，默认为开启
            const savedAutoScroll = localStorage.getItem('autoScrollEnabled');
            autoScrollEnabled = savedAutoScroll !== null ? savedAutoScroll === 'true' : true;

            if (autoScrollEnabled) {
                autoScrollBtnEl.classList.add('active');
                autoScrollTextEl.textContent = '🔄 自动滚动';
            } else {
                autoScrollBtnEl.classList.remove('active');
                autoScrollTextEl.textContent = '⏸️ 手动滚动';
            }
        }

        // 初始化逗号换行模式设置
        function initCommaMode() {
            // 从本地存储获取逗号换行模式设置，默认为关闭
            const savedCommaMode = localStorage.getItem('commaMode');
            commaMode = savedCommaMode === 'true';

            if (commaMode) {
                commaModeBtnEl.classList.add('active');
                commaModeTextEl.textContent = '📝 逗号换行';
            } else {
                commaModeBtnEl.classList.remove('active');
                commaModeTextEl.textContent = '📝 逗号换行';
            }
        }

        // 切换逗号换行模式
        function toggleCommaMode() {
            commaMode = !commaMode;

            if (commaMode) {
                commaModeBtnEl.classList.add('active');
                commaModeTextEl.textContent = '📝 逗号换行';
            } else {
                commaModeBtnEl.classList.remove('active');
                commaModeTextEl.textContent = '📝 逗号换行';
                // 关闭模式时清除逗号分割显示
                clearCommaSplitDisplay();
            }

            // 保存设置到本地存储
            localStorage.setItem('commaMode', commaMode);
        }

        // 设置悬浮事件 - 简化版本，主要依靠CSS
        function setupHoverEvents() {
            // CSS已经处理了主要的hover逻辑，这里只需要处理一些边缘情况
            // 不需要复杂的JavaScript事件监听
        }

        // 逗号换行模式处理函数
        function processCommaMode() {
            if (!currentIncomplete.trim()) {
                clearCommaSplitDisplay();
                return;
            }

            // 使用逗号分割句子
            const segments = splitByComma(currentIncomplete);
            updateCommaSplitDisplay(segments);
        }

        // 按逗号分割句子
        function splitByComma(text) {
            if (!text || !text.trim()) {
                return [];
            }

            const segments = [];
            let currentSegment = '';

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                currentSegment += char;

                // 检测逗号（包括中英文逗号）
                if (char === ',' || char === '，') {
                    const trimmedSegment = currentSegment.trim();
                    if (trimmedSegment) {
                        segments.push(trimmedSegment);
                    }
                    currentSegment = '';
                }
            }

            // 添加最后一个片段（如果有的话）
            const finalSegment = currentSegment.trim();
            if (finalSegment) {
                segments.push(finalSegment);
            }

            return segments;
        }

        // 更新逗号分割显示
        function updateCommaSplitDisplay(segments) {
            const incompleteEl = document.getElementById('current-incomplete');
            if (!incompleteEl) {
                return;
            }

            // 查找或创建逗号分割容器
            let splitContainer = incompleteEl.querySelector('.comma-split-container');
            if (!splitContainer) {
                splitContainer = document.createElement('div');
                splitContainer.className = 'comma-split-container';
                incompleteEl.appendChild(splitContainer);
            }

            // 比较新旧分割结果，只更新变化的部分
            const existingSegments = Array.from(splitContainer.children);

            // 更新或创建分割句子元素
            segments.forEach((segment, index) => {
                let segmentEl = existingSegments[index];

                if (!segmentEl) {
                    // 创建新的分割句子元素
                    segmentEl = document.createElement('div');
                    segmentEl.className = 'comma-split-sentence updating';
                    addNoTranslateAttributes(segmentEl);
                    splitContainer.appendChild(segmentEl);
                } else if (segmentEl.textContent !== segment) {
                    // 内容发生变化，重新标记为更新中
                    segmentEl.className = 'comma-split-sentence updating';
                    addNoTranslateAttributes(segmentEl);
                }

                segmentEl.textContent = segment;
            });

            // 移除多余的分割句子元素
            while (existingSegments.length > segments.length) {
                const extraEl = existingSegments.pop();
                if (extraEl && extraEl.parentNode) {
                    extraEl.parentNode.removeChild(extraEl);
                }
            }

            // 启动稳定化定时器
            startCommaSplitStabilizeTimer();
        }

        // 清除逗号分割显示
        function clearCommaSplitDisplay() {
            const incompleteEl = document.getElementById('current-incomplete');
            if (incompleteEl) {
                const splitContainer = incompleteEl.querySelector('.comma-split-container');
                if (splitContainer) {
                    splitContainer.remove();
                }
            }
            commaSplitSentences = [];
        }

        // 启动逗号分割稳定化定时器
        function startCommaSplitStabilizeTimer() {
            // 清除之前的定时器
            if (window.commaSplitStabilizeTimer) {
                clearTimeout(window.commaSplitStabilizeTimer);
            }

            // 设置新的定时器，2秒后将更新中的分割句子标记为稳定
            window.commaSplitStabilizeTimer = setTimeout(() => {
                stabilizeCommaSplitSentences();
            }, 2000);
        }

        // 将更新中的逗号分割句子标记为稳定
        function stabilizeCommaSplitSentences() {
            const incompleteEl = document.getElementById('current-incomplete');
            if (incompleteEl) {
                const updatingSegments = incompleteEl.querySelectorAll('.comma-split-sentence.updating');
                updatingSegments.forEach(segment => {
                    segment.classList.remove('updating');
                    segment.classList.add('stable');
                    removeNoTranslateAttributes(segment);
                });
            }
        }

        // Telegraph相关功能
        let telegraphAccessToken = null;

        // 将文本转换为Telegraph Node格式
        function textToTelegraphNodes(text) {
            if (!text || !text.trim()) {
                return [];
            }

            // 简单的段落分割，每个句子作为一个段落
            const sentences = text.split(/[.。！!？?]/).filter(s => s.trim());
            const nodes = [];

            sentences.forEach(sentence => {
                const trimmed = sentence.trim();
                if (trimmed) {
                    nodes.push({
                        tag: 'p',
                        children: [trimmed + '.']
                    });
                }
            });

            return nodes.length > 0 ? nodes : [{
                tag: 'p',
                children: [text]
            }];
        }

        // 将包含翻译的内容转换为Telegraph Node格式
        function contentWithTranslationToTelegraphNodes(sentencePairs) {
            if (!sentencePairs || sentencePairs.length === 0) {
                return [];
            }

            const nodes = [];

            // 遍历每个句子对
            sentencePairs.forEach(pair => {
                const original = pair.original.trim();
                const translation = pair.translation.trim();

                if (original) {
                    // 原文段落
                    nodes.push({
                        tag: 'p',
                        children: [original]
                    });

                    // 翻译段落（如果存在），紧跟在原文后面
                    if (translation) {
                        nodes.push({
                            tag: 'p',
                            children: [{
                                tag: 'em',
                                children: [translation]
                            }]
                        });
                    }

                    // 添加分隔空行（在每组原文+翻译后）
                    nodes.push({
                        tag: 'p',
                        children: ['']
                    });
                }
            });

            return nodes.length > 0 ? nodes : [{
                tag: 'p',
                children: ['No content available']
            }];
        }

        // 提取沉浸式翻译的内容
        function extractImmersiveTranslationContent() {
            const completedSentenceElements = document.querySelectorAll('.sentence.completed');
            const sentencePairs = [];

            completedSentenceElements.forEach(sentenceEl => {
                // 提取原文
                const sentenceTextEl = sentenceEl.querySelector('.sentence-text');
                let originalContent = '';
                let translationContent = '';

                if (sentenceTextEl) {
                    // 获取原文内容
                    originalContent = sentenceTextEl.getAttribute('data-text') || '';

                    // 如果没有data-text属性，尝试从文本内容中提取（排除翻译部分）
                    if (!originalContent) {
                        // 克隆元素以避免修改原DOM
                        const clonedEl = sentenceTextEl.cloneNode(true);
                        // 移除翻译相关的元素
                        const translationElements = clonedEl.querySelectorAll('.immersive-translate-target-wrapper, .immersive-translate-target-inner, [data-immersive-translate-translation-element-mark]');
                        translationElements.forEach(el => el.remove());
                        originalContent = clonedEl.textContent.trim();
                    }

                    // 提取翻译内容
                    const translationEl = sentenceEl.querySelector('.immersive-translate-target-inner');
                    if (translationEl) {
                        translationContent = translationEl.textContent.trim();
                    }
                }

                // 如果有原文内容，添加到数组中
                if (originalContent && originalContent.trim()) {
                    sentencePairs.push({
                        original: originalContent.trim(),
                        translation: translationContent || ''
                    });
                }
            });

            // 如果有未完成的句子，也包含进来
            if (currentIncomplete.trim()) {
                sentencePairs.push({
                    original: currentIncomplete.trim(),
                    translation: ''
                });
            }

            return sentencePairs;
        }

        // 获取或创建Telegraph账户
        async function ensureTelegraphAccount() {
            if (telegraphAccessToken) {
                return telegraphAccessToken;
            }

            try {
                const response = await fetch('https://api.telegra.ph/createAccount', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        short_name: 'LiveCaptions',
                        author_name: 'Live Captions User',
                        author_url: ''
                    })
                });

                const data = await response.json();
                if (data.ok) {
                    telegraphAccessToken = data.result.access_token;
                    // 保存到本地存储
                    localStorage.setItem('telegraphAccessToken', telegraphAccessToken);
                    return telegraphAccessToken;
                } else {
                    throw new Error(data.error || '创建Telegraph账户失败');
                }
            } catch (error) {
                console.error('创建Telegraph账户失败:', error);
                throw error;
            }
        }

        // 发送到Telegraph
        async function sendToTelegraph() {
            const telegraphBtn = document.getElementById('telegraph-btn');
            const titleInput = document.querySelector('.editable-title');

            // 检查是否有内容
            if (completedSentences.length === 0 && !currentIncomplete.trim()) {
                alert('没有内容可以发送到Telegraph');
                return;
            }

            // 禁用按钮并显示加载状态
            telegraphBtn.disabled = true;
            telegraphBtn.textContent = '发送中...';

            try {
                // 确保有Telegraph账户
                const accessToken = await ensureTelegraphAccount();

                // 获取标题
                const title = titleInput.value.trim() || 'Live Captions';

                // 准备内容
                let allText = '';
                if (completedSentences.length > 0) {
                    allText = completedSentences.join(' ');
                }
                if (currentIncomplete.trim()) {
                    allText += (allText ? ' ' : '') + currentIncomplete;
                }

                // 转换为Telegraph Node格式
                const content = textToTelegraphNodes(allText);

                // 创建Telegraph页面
                const response = await fetch('https://api.telegra.ph/createPage', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        access_token: accessToken,
                        title: title,
                        author_name: 'Live Captions',
                        content: JSON.stringify(content),
                        return_content: false
                    })
                });

                const data = await response.json();
                if (data.ok) {
                    const pageUrl = data.result.url;
                    // 在新窗口中打开Telegraph页面
                    window.open(pageUrl, '_blank');

                    // 显示成功消息
                    alert(`成功发送到Telegraph！\n页面链接：${pageUrl}`);
                } else {
                    throw new Error(data.error || '创建Telegraph页面失败');
                }

            } catch (error) {
                console.error('发送到Telegraph失败:', error);
                alert('发送到Telegraph失败：' + error.message);
            } finally {
                // 恢复按钮状态
                telegraphBtn.disabled = false;
                telegraphBtn.textContent = '发送到Telegraph';
            }
        }

        // 发送包含翻译的内容到Telegraph
        async function sendToTelegraphWithTranslation() {
            const telegraphWithTranslationBtn = document.getElementById('telegraph-with-translation-btn');
            const titleInput = document.querySelector('.editable-title');

            // 检查是否有内容
            if (completedSentences.length === 0 && !currentIncomplete.trim()) {
                alert('没有内容可以发送到Telegraph');
                return;
            }

            // 禁用按钮并显示加载状态
            telegraphWithTranslationBtn.disabled = true;
            telegraphWithTranslationBtn.textContent = '发送中...';

            try {
                // 确保有Telegraph账户
                const accessToken = await ensureTelegraphAccount();

                // 获取标题
                const title = titleInput.value.trim() || 'Live Captions (双语版)';

                // 提取原文和翻译内容
                const sentencePairs = extractImmersiveTranslationContent();

                console.log('提取的句子对:', sentencePairs);

                // 检查是否有翻译内容
                const hasTranslations = sentencePairs.some(pair => pair.translation.trim());
                if (!hasTranslations) {
                    // 如果没有翻译内容，提示用户
                    const useOriginalOnly = confirm('未检测到翻译内容，是否只发送原文？\n\n提示：请确保沉浸式翻译插件已经翻译了页面内容。');
                    if (!useOriginalOnly) {
                        telegraphWithTranslationBtn.disabled = false;
                        telegraphWithTranslationBtn.textContent = '发送到Telegraph(含翻译)';
                        return;
                    }
                }

                // 转换为Telegraph Node格式（包含翻译）
                const content = contentWithTranslationToTelegraphNodes(sentencePairs);

                // 创建Telegraph页面
                const response = await fetch('https://api.telegra.ph/createPage', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        access_token: accessToken,
                        title: title,
                        author_name: 'Live Captions',
                        content: JSON.stringify(content),
                        return_content: false
                    })
                });

                const data = await response.json();
                if (data.ok) {
                    const pageUrl = data.result.url;
                    // 在新窗口中打开Telegraph页面
                    window.open(pageUrl, '_blank');

                    // 显示成功消息
                    const hasTranslation = hasTranslations ? '（包含翻译）' : '（仅原文）';
                    alert(`成功发送到Telegraph${hasTranslation}！\n页面链接：${pageUrl}`);
                } else {
                    throw new Error(data.error || '创建Telegraph页面失败');
                }

            } catch (error) {
                console.error('发送到Telegraph失败:', error);
                alert('发送到Telegraph失败：' + error.message);
            } finally {
                // 恢复按钮状态
                telegraphWithTranslationBtn.disabled = false;
                telegraphWithTranslationBtn.textContent = '发送到Telegraph(含翻译)';
            }
        }

        // 防止沉浸翻译的MutationObserver（只保护未完成的句子）
        function setupImmersiveTranslateProtection() {
            const captionsContainer = document.getElementById('captions-container');
            if (!captionsContainer) return;

            // 创建MutationObserver来监听DOM变化
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    // 检查是否有新添加的节点
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === Node.ELEMENT_NODE) {
                                // 只对未完成句子中的元素移除沉浸翻译属性
                                const incompleteParent = node.closest('.sentence.incomplete');
                                if (incompleteParent) {
                                    removeImmersiveTranslateAttributes(node);
                                }
                            }
                        });
                    }

                    // 检查属性变化
                    if (mutation.type === 'attributes') {
                        const target = mutation.target;
                        if (target.nodeType === Node.ELEMENT_NODE) {
                            // 只保护未完成句子中的元素
                            const incompleteParent = target.closest('.sentence.incomplete');
                            if (incompleteParent && mutation.attributeName &&
                                mutation.attributeName.includes('immersive-translate')) {
                                target.removeAttribute(mutation.attributeName);
                            }
                        }
                    }
                });
            });

            // 开始观察字幕容器
            observer.observe(captionsContainer, {
                childList: true,
                subtree: true,
                attributes: true,
                attributeFilter: ['data-immersive-translate-walked', 'data-immersive-translate-paragraph']
            });
        }

        // 移除沉浸翻译属性的函数
        function removeImmersiveTranslateAttributes(element) {
            // 移除沉浸翻译可能添加的属性
            const immersiveAttrs = [
                'data-immersive-translate-walked',
                'data-immersive-translate-paragraph',
                'data-immersive-translate-translation-element-mark'
            ];

            immersiveAttrs.forEach(attr => {
                if (element.hasAttribute(attr)) {
                    element.removeAttribute(attr);
                }
            });

            // 递归处理子元素
            if (element.children) {
                Array.from(element.children).forEach(child => {
                    removeImmersiveTranslateAttributes(child);
                });
            }
        }

        // 全局错误处理器，用于捕获扩展脚本错误
        window.addEventListener('error', (event) => {
            // 检查是否是扩展脚本错误（通常包含特定的文件名或错误信息）
            if (event.filename && (
                event.filename.includes('a2_hightlight.js') ||
                event.filename.includes('chrome-extension://') ||
                event.filename.includes('moz-extension://')
            )) {
                console.warn('捕获到扩展脚本错误，已忽略:', event.error);
                event.preventDefault(); // 阻止错误冒泡
                return true;
            }

            // 检查错误消息是否与DOM操作相关
            if (event.error && event.error.message && (
                event.error.message.includes('closest') ||
                event.error.message.includes('Cannot read properties of null') ||
                event.error.message.includes('Cannot read properties of undefined')
            )) {
                console.warn('捕获到DOM操作错误，可能来自扩展脚本:', event.error);
                event.preventDefault();
                return true;
            }
        });

        // 页面加载完成后初始化
        window.addEventListener('load', () => {
            initTheme();
            initControls();
            initAutoScroll();
            initCommaMode();

            // 初始化统计显示
            updateStats();
            updateListeningTime();

            // 设置沉浸翻译防护
            setupImmersiveTranslateProtection();

            // 从本地存储恢复Telegraph访问令牌
            const savedToken = localStorage.getItem('telegraphAccessToken');
            if (savedToken) {
                telegraphAccessToken = savedToken;
            }

            setTimeout(startPolling, 1000);
        });

        // 页面关闭时停止轮询
        window.addEventListener('beforeunload', stopPolling);
    </script>
</body>
</html>
